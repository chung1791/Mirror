using Mirror.RemoteCalls;
using NUnit.Framework;
using UnityEngine;
using UnityEngine.TestTools;

namespace Mirror.Tests
{
    class EmptyBehaviour : NetworkBehaviour {}

    // we need to inherit from networkbehaviour to test protected functions
    public class NetworkBehaviourDelegateComponent : NetworkBehaviour
    {
        public static void Delegate(NetworkBehaviour comp, NetworkReader reader, NetworkConnection senderConnection) {}
        public static void Delegate2(NetworkBehaviour comp, NetworkReader reader, NetworkConnection senderConnection) {}
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class NetworkBehaviourSetSyncVarGameObjectComponent : NetworkBehaviour
    {
        //[SyncVar]
        public GameObject test;
        // usually generated by weaver
        public uint testNetId;
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class NetworkBehaviourGetSyncVarGameObjectComponent : NetworkBehaviour
    {
        //[SyncVar]
        public GameObject test;
        // usually generated by weaver
        public uint testNetId;
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class NetworkBehaviourSetSyncVarNetworkIdentityComponent : NetworkBehaviour
    {
        //[SyncVar]
        public NetworkIdentity test;
        // usually generated by weaver
        public uint testNetId;
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class NetworkBehaviourGetSyncVarNetworkIdentityComponent : NetworkBehaviour
    {
        //[SyncVar]
        public NetworkIdentity test;
        // usually generated by weaver
        public uint testNetId;
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class OnStopClientComponent : NetworkBehaviour
    {
        public int called;
        public override void OnStopClient() => ++called;
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class OnStartClientComponent : NetworkBehaviour
    {
        public int called;
        public override void OnStartClient() => ++called;
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class OnStartLocalPlayerComponent : NetworkBehaviour
    {
        public int called;
        public override void OnStartLocalPlayer() => ++called;
    }

    public class NetworkBehaviourTests : MirrorEditModeTest
    {
        [TearDown]
        public override void TearDown()
        {
            NetworkServer.RemoveLocalConnection();
            base.TearDown();
        }

        [Test]
        public void IsServerOnly()
        {
            CreateNetworked(out _, out NetworkIdentity identity, out EmptyBehaviour emptyBehaviour);

            // call OnStartServer so isServer is true
            identity.OnStartServer();
            Assert.That(identity.isServer, Is.True);

            // isServerOnly should be true when isServer = true && isClient = false
            Assert.That(emptyBehaviour.isServer, Is.True);
            Assert.That(emptyBehaviour.isClient, Is.False);
            Assert.That(emptyBehaviour.isServerOnly, Is.True);
        }

        [Test]
        public void IsClientOnly()
        {
            CreateNetworked(out _, out NetworkIdentity identity, out EmptyBehaviour emptyBehaviour);

            // isClientOnly should be true when isServer = false && isClient = true
            identity.isClient = true;
            Assert.That(emptyBehaviour.isServer, Is.False);
            Assert.That(emptyBehaviour.isClient, Is.True);
            Assert.That(emptyBehaviour.isClientOnly, Is.True);
        }

        [Test]
        public void HasNoAuthorityByDefault()
        {
            // no authority by default
            CreateNetworked(out _, out _, out EmptyBehaviour emptyBehaviour);
            Assert.That(emptyBehaviour.hasAuthority, Is.False);
        }

        [Test]
        public void HasIdentitysNetId()
        {
            CreateNetworked(out _, out NetworkIdentity identity, out EmptyBehaviour emptyBehaviour);
            identity.netId = 42;
            Assert.That(emptyBehaviour.netId, Is.EqualTo(42));
        }

        [Test]
        public void HasIdentitysConnectionToServer()
        {
            CreateNetworked(out _, out NetworkIdentity identity, out EmptyBehaviour emptyBehaviour);
            identity.connectionToServer = new LocalConnectionToServer();
            Assert.That(emptyBehaviour.connectionToServer, Is.EqualTo(identity.connectionToServer));
        }

        [Test]
        public void HasIdentitysConnectionToClient()
        {
            CreateNetworked(out _, out NetworkIdentity identity, out EmptyBehaviour emptyBehaviour);
            identity.connectionToClient = new LocalConnectionToClient();
            Assert.That(emptyBehaviour.connectionToClient, Is.EqualTo(identity.connectionToClient));
        }

        [Test]
        public void ComponentIndex()
        {
            // create a NetworkIdentity with two components
            CreateNetworked(out GameObject _, out NetworkIdentity _, out EmptyBehaviour first, out EmptyBehaviour second);
            Assert.That(first.ComponentIndex, Is.EqualTo(0));
            Assert.That(second.ComponentIndex, Is.EqualTo(1));
        }

        [Test, Ignore("NetworkServerTest.SendCommand does it already")]
        public void SendCommandInternal() {}

        [Test, Ignore("ClientRpcTest.cs tests Rpcs already")]
        public void SendRPCInternal() {}

        [Test, Ignore("TargetRpcTest.cs tests TargetRpcs already")]
        public void SendTargetRPCInternal() {}

        [Test]
        public void RegisterDelegateDoesntOverwrite()
        {
            // registerdelegate is protected, but we can use
            // RegisterCommandDelegate which calls RegisterDelegate
            int registeredHash1 = RemoteCallHelper.RegisterDelegate(
                typeof(NetworkBehaviourDelegateComponent),
                nameof(NetworkBehaviourDelegateComponent.Delegate),
                MirrorInvokeType.Command,
                NetworkBehaviourDelegateComponent.Delegate,
                false);

            // registering the exact same one should be fine. it should simply
            // do nothing.
            int registeredHash2 = RemoteCallHelper.RegisterDelegate(
                typeof(NetworkBehaviourDelegateComponent),
                nameof(NetworkBehaviourDelegateComponent.Delegate),
                MirrorInvokeType.Command,
                NetworkBehaviourDelegateComponent.Delegate,
                false);

            // registering the same name with a different callback shouldn't
            // work
            LogAssert.Expect(LogType.Error, $"Function {typeof(NetworkBehaviourDelegateComponent)}.{nameof(NetworkBehaviourDelegateComponent.Delegate)} and {typeof(NetworkBehaviourDelegateComponent)}.{nameof(NetworkBehaviourDelegateComponent.Delegate2)} have the same hash.  Please rename one of them");
            int registeredHash3 = RemoteCallHelper.RegisterDelegate(
                typeof(NetworkBehaviourDelegateComponent),
                nameof(NetworkBehaviourDelegateComponent.Delegate),
                MirrorInvokeType.Command,
                NetworkBehaviourDelegateComponent.Delegate2,
                false);

            // clean up
            RemoteCallHelper.RemoveDelegate(registeredHash1);
            RemoteCallHelper.RemoveDelegate(registeredHash2);
            RemoteCallHelper.RemoveDelegate(registeredHash3);
        }

        [Test]
        public void GetDelegate()
        {
            // registerdelegate is protected, but we can use
            // RegisterCommandDelegate which calls RegisterDelegate
            int registeredHash = RemoteCallHelper.RegisterDelegate(
                typeof(NetworkBehaviourDelegateComponent),
                nameof(NetworkBehaviourDelegateComponent.Delegate),
                MirrorInvokeType.Command,
                NetworkBehaviourDelegateComponent.Delegate,
                false);

            // get handler
            int cmdHash = RemoteCallHelper.GetMethodHash(typeof(NetworkBehaviourDelegateComponent), nameof(NetworkBehaviourDelegateComponent.Delegate));
            CmdDelegate func = RemoteCallHelper.GetDelegate(cmdHash);
            CmdDelegate expected = NetworkBehaviourDelegateComponent.Delegate;
            Assert.That(func, Is.EqualTo(expected));

            // invalid hash should return null handler
            CmdDelegate funcNull = RemoteCallHelper.GetDelegate(1234);
            Assert.That(funcNull, Is.Null);

            // clean up
            RemoteCallHelper.RemoveDelegate(registeredHash);
        }

        [Test]
        public void SerializeAndDeserializeObjectsAll()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity _, out NetworkBehaviourWithSyncVarsAndCollections comp);

            // add values to synclist
            comp.list.Add(42);
            comp.list.Add(43);

            // serialize it
            NetworkWriter writer = new NetworkWriter();
            comp.SerializeObjectsAll(writer);

            // clear original list
            comp.list.Clear();
            Assert.That(comp.list.Count, Is.EqualTo(0));

            // deserialize it
            NetworkReader reader = new NetworkReader(writer.ToArray());
            comp.DeSerializeObjectsAll(reader);
            Assert.That(comp.list.Count, Is.EqualTo(2));
            Assert.That(comp.list[0], Is.EqualTo(42));
            Assert.That(comp.list[1], Is.EqualTo(43));
        }

        [Test]
        public void SerializeAndDeserializeObjectsDelta()
        {
            // SyncLists are only set dirty while owner has observers.
            // need a connection.
            NetworkServer.Listen(1);
            ConnectHostClientBlockingAuthenticatedAndReady();

            CreateNetworkedAndSpawn(out GameObject _, out NetworkIdentity _, out NetworkBehaviourWithSyncVarsAndCollections comp);

            // add to synclist
            comp.list.Add(42);
            comp.list.Add(43);

            // serialize it
            NetworkWriter writer = new NetworkWriter();
            comp.SerializeObjectsDelta(writer);

            // clear original list
            comp.list.Clear();
            Assert.That(comp.list.Count, Is.EqualTo(0));

            // deserialize it
            NetworkReader reader = new NetworkReader(writer.ToArray());
            comp.DeSerializeObjectsDelta(reader);
            Assert.That(comp.list.Count, Is.EqualTo(2));
            Assert.That(comp.list[0], Is.EqualTo(42));
            Assert.That(comp.list[1], Is.EqualTo(43));
        }

        [Test]
        public void OnStopClient()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity, out OnStopClientComponent comp);
            identity.OnStopClient();
            Assert.That(comp.called, Is.EqualTo(1));
        }

        [Test]
        public void OnStartClient()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity, out OnStartClientComponent comp);
            identity.OnStartClient();
            Assert.That(comp.called, Is.EqualTo(1));
        }

        [Test]
        public void OnStartLocalPlayer()
        {
            CreateNetworked(out GameObject _, out NetworkIdentity identity, out OnStartLocalPlayerComponent comp);
            identity.OnStartLocalPlayer();
            Assert.That(comp.called, Is.EqualTo(1));
        }
    }

    // we need to inherit from networkbehaviour to test protected functions
    public class NetworkBehaviourInitSyncObjectTester : NetworkBehaviour
    {
        [Test]
        public void InitSyncObject()
        {
            SyncObject syncObject = new SyncList<bool>();
            InitSyncObject(syncObject);
            Assert.That(syncObjects.Count, Is.EqualTo(1));
            Assert.That(syncObjects[0], Is.EqualTo(syncObject));
        }
    }
}
